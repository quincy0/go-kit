# 工程规范(重点)

工程规范主要解决的是项目如何组织的问题，在这个过程中应该尽可能的考虑性能、可扩展性、可维护性等问题。原则上，所有新开的工程都应该使用goctl来自动生成。比如，要创建一个帐号服务，可以分以下两步来进行：

1. 先创建对应的api模板文件account.api
2. 使用goctl生成工程，例如：goctl api go -api account.api -dir account



## 1. Golang工程结构

使用goctl生成的工程初始结构如下(go.mod需要自己init)：

```
├── Dockerfile			// goctl根据api模板自动生成的Dockerfile
├── README.md			// 工和说明文档
├── cloudbuild.yaml		// goctl根据api模拟自动生成的Cloud Run 配置文件
├── etc				// 所有配置文件都放在这个目录下面
│   └── account-api.yaml	// 配置文件
├── account.go			// 程序入口文件
├── go.mod													
├── go.sum
└── internal		        // 工程核心代码
    ├── config			// 配置相关的代码
    │   └── config.go
    ├── handler			// Api的Handler，只接收请求转到logic层
    │   ├── loginhandler.go     // 原则上，某一类业务使用一个独立的Handler
    │   └── routes.go		// 所有API接口的路由信息
    ├── logic			// 业务逻辑
    │   └── loginlogic.go	// 原则上，某一类业务使用独立的logic 
    ├── svc			// 依赖注入上下文，相关的中间件、服务公共资源通过在这里初始化后透传到下游
    │   └── servicecontext.go	
    ├── model			// 数据模型, 对数据表的映射及数据库的操作(这个不是goctl自动生成的)
    │   └── usermodel.go					
    └── types			// 所有的参数与返回都定义在这里
        └── types.go
```

Golang中，还有一个有特殊意义的pkg目录，上面并没有出现。对于共公的代码建议都在github.com/quincy0/go-kit仓库维护，如果确实有一些还没有完全想好的代码，或者涉及到很多
和第三方交互有很多三方库也是可以新建一个pkg目录的。

### 1.1. 命名规范

- **工程名**：全小写命名，多个单词用"-"分隔，格式为：技术栈+工程名，例如：go-user-account
- **目录命令**： 目录名用全小写命令，例如：user
- **文件名**：
  - Handler：handler使用全小写命名，以handler结尾。注意："handler"小写，例如：loginhandler.go
  - Logic：使用全小写命名，以logic结尾。例如：loginlogic.go
  - Model:  使用全小写命名，以model结尾，例如：accountmodel.go

注意：文件名应该尽可能的短，尽量不用下划线



### 1.2. 行动指南

**1. 多个层/模块有相同的结构体/变量应该放哪里？**

答： 有些时候，多个模块之间可能会引用相同的结构体，这个时候可以将声明放在types目录，但要注意不要直接在types里面写，而是要重新建一个新的go文件来承载。
例如，公共的error，可以在internal/types目录下新建一个errors.go文件，将error声明在文件中。如下：
```bigquery
var (
	ErrNotFound      = &errorx.CodeError{400, "Not found", "not_found"}
	ErrNotPermission = &errorx.CodeError{403, "Not permission", "not_permission"}
)
```
再例如，工程用到的常量，可以在internal/types目录下新建一个define.go,如下：
```bigquery
const (
	TypeDigital        = 1 // 数字文件
	TypeVedioAudio     = 2 // Video/Audio Message
	TypePhoneVideoCall = 3 // Phone/Video Call
	TypePreMiumDms     = 4 // PreMiumDMS
	TypeAffiliateGood  = 5 // AffiliateProducts
)
```


**2. model目录具体有啥用？**

答：model目录里面声明结构体用来映射具体数据表字段，对数据库的增删改查代码都写在对应的model文件里，这块可以参考编码规范。



**3. 如何加一个独立的功能？**

答：如果我要给当前服务加一个自字义的本地缓存功能，可以在internal目录下创建一个cache目录，相关的代码写在cache目录下。



## 2. 新增/删除接口

新增/删除接口要使用goctl来实现，goctl在第一次生成工程之后，可以对api模板文件进行二次编辑重新使用goctl生成，这里有几个要注意的地方：

### 2.1. 保留文件

保留文件是goctl每次运行之后都会覆盖掉原来内容的文件，目前一共有两个保留文件，分别是：

- internal/handler/routes.go
- internal/types/types.go

注意：这两个文件不能直接修改，而是应该使用goctl工具自动覆盖。这两个文件中也会有相应的提示，内容如下：

```
// Code generated by goctl. DO NOT EDIT.
```



## 3. 测试

### 3.1. 单元测试

原则上，logic层需要写单元测试，测试文件名为：文件名+_test.go



### 3.2. 性能测试

TODO



## 4. 日志

这里日志还是以github.com/quincy0/go-kit库里的日志为准。

#### 4.1. 日志级别

目前github.com/quincy0/go-kit中日志有以下几个级别：

```
levelAlert  = "alert"		// 可以认为是一个提示，可以当作debug来用
levelInfo   = "info"			
levelError  = "error"		// 非常严重的错误，比如MySQL挂了
levelSevere = "severe"		// 这个业务上一般用不到
levelFatal  = "fatal"		// 要慎用
levelSlow   = "slow"		// 在业务上一般用不到
levelStat   = "stat"		// 在业务上一般用不到
```

其中，fatal应该少用，甚至不用。在我们的业务中，应该只会用到alert、info、error。

1. alert：用在一些难以肉眼看出来问题的地方，可以借助日志来调试
2. info: 关键步骤的日志，比如用户注册流程中用户信息是否被正确插入到数据库
3. error:  比如支付失败了、MySQL挂了、缓存穿透到MySQL了 



#### 4.2. 日志格式

日志格式以github.com/quincy0/go-kit库输出为准，但在写入时要遵守以下约定：

- 格式为：k=>v，比如记录用户ID，应该是userId=1024或者userId:1024，而不是1024

  

#### 4.3. 日志内容

日志内容应遵循以下约定：

- 最小化原则，比如一个20个字段的结构体，实际我们只关心其中某一个字段，那就只打印这一个字段
- 尽量使用格式化工具，比如json



