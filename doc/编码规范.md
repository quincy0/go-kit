# 编码规范

编码规范强写代码过程中应该遵循的相关规范。比如：函数变量的命名、代码格式以及相关语言特性约定俗称使用。

## 1.代码风格

### 1.1. 代码格式统一

- 代码必须使用gofmt进行格式化，最佳方式：在golang ide打开gofmt工具
- 每行代码建议不超过120字符（例外，比如import、工具生成的代码、带tag的struct等）
- 每个文件长度不超过800行
- 每个函数不超过80行
- import 
    - import需要使用goimports格式化，最佳方式：在golang ide设置goimports保存自动format
    包名和实际使用名称不一致的时候，要重命名，例如：
    - 导入包进行分组，大致可以分为标准库、内部包、三方包、以及匿名包，例如：

​		例如：

```go
    // 包重命名
    // bad
    "github.com/dgrijalva/jwt-go/v4"
    
    // good
    jwt "github.com/dgrijalva/jwt-go/v4"
    
    // 包分组
    // 标准库
    "fmt"
    "time"
    "os"
    
    // 内部包
    "github.com/hubbuy/core/ztime"
    "github.com/hubbuy/httpx/config"
    
    // 三方包
    "github.com/jinzhu/gorm"
    "github.com/spf13/viper"
    
    // 匿名包
    _ "github.com/jinzhu/gorm/dialects/mysql"
    
```



### 1.2. 声明、初始化

- 初始化结构引用，使用&T{}而不是new(T)，使期与结构体保持一致

  ```go
  // bad
  sptr := new(T)
  sptr.Name = "tom"
  
  // good
  sptr := &T{Name: "tome"}
  ```

  

- 当函数中需要使用到多个变量时，可以在函数开始处使用var声明。在函数外部声明必须使用var，不要用:=

  ```go
  var (
  	err error
  	user *model.User
  )
  ```

- 尽可能事先指明容器容量

  ```go
  m := make(map[int]string, 4)
  s := make([]string, 0, 4)
  ```

- 嵌入式类型应位于结构体内的字段列表顶部，并且需要一个空行和其它字段分隔

  ```go
  // bad 
  type Client struct {
  	name string 
  	http.Client
  }
  
  // good
  type Client struct {
  	http.Client 
  	
  	name string
  }
  ```

  

### 1.3.错误处理

- 必须处理返回的error（除非非常确定的场景）

  ```go
  func load() error {
  	// code
  }
  
  // bad
  load()
  
  // good
  _ = load()
  ```

- error作为返回参数时，必须放到最后

  ```go
  // bad 
  func load() (error, int) {
  	// code
  }
  
  // good
  func load() (int, error) {
  	// code
  }
  ```

- 尽早处理原则

  ```go
  // bad 
  if err != nil {
  	// error code
  } else {
  	// normal code
  }
  
  // good
  if err != nil {
  	// error handle
  }
  // normal code
  ```

- 需要在if之外使用函数调用的结果，应采用下面的方式

  ```go
  // bad
  if v, err := foo(); err != nil {
  	// error handle
  }
  
  // good
  v, err := foo()
  if err != nil {
  	// error handle
  }
  ```

- 错误单独判断

  ```go
  // bad
  v, err := foo()
  if err != nil || v == nil {
  	// error handle
  	return err 
  }
  
  // good
  v, err := foo()
  if err != nil {
  	// error handle
  	return err 
  }
  if v == nil {
  	// error handle
  	return errors.New("invalid val v")
  }
  ```

- 错误描述规定

  - 返回用户可以做什么，而不是不能做什么

  - 用must而不是should。例如，must be greater than 0

  - 引用字符串时，在单引号中指定该名称。例如：ust not contian 'xxx'

  - 错误描述用小写字母开头，结尾不要加标点

    ```go
    // bad
    errors.New("Redis connection failed")
    
    // good
    errors.New("redis connection failed")
    ```

    

### 1.4. panic 

- 业务逻辑中禁止使用panic
- 在main包中，使用log.Fatal记录错误，这样可以记录到异常日志中
- 包内用error而不是panic来传递错误



### 1.5.断言处理

type assert的单个返回值针对不正确的类型将产生panic

```go
// bad
t := n.(int)

// good
t, ok := n.(int)
if !ok {
	// error handle
}
// code
```



## 2.命名规范

### 2.1.包命名

- 包名必须和目录名一致，尽量采用有意义、简短的包名，不要和标准库冲突
- 包名全部小写，没有大小写和下划线，使用目录划分层级
- 项目名通过中划线连接多个单词
- 包名不使用复数，例如: net/url   而不是：net/urls
- 不使用common、util、lib这类包名
- 包名要尽量简短，例如：log、time、net

### 2.2.函数命名

- 函数使用驼峰命名，首字线决定包外访问权限
- 代码生成工具自动生成代码(例如：xxx.pb.go、usermodel_gen.go)和为了对相关测试用例进行分组

### 2.3.文件命名

- 简短有意义
- 文件名小写，全小写，不包含下划线
- 框架内hander、logic、model层需要加相应后缀。例如：userinfologic.go、usermodel.go、userinfohandle.go

### 2.4.结构体命名

- 驼峰命名，大小写控制包外访问权限

- 结构体名应该使用名词，比如Node、NodeSpec

- 避免使用无意义的结构体名，例如：Data、Info

- 结构体声明和初始化都采用多行例如：

  ```go
  // User 声明
  type User struct {
  	Name  string 
  	Email string 
  }
  
  // 多行初始化
  u := User {
  	Name: "tom",
  	Email: "support@hubbuy.com",
  }
  ```

  

### 2.5.接口全名

- 接口命名规则和结构体基本一致
  - 单个函数的接口名以“er”作为后缀（例如Reader、Pusher）， 不必在意英文语法
  - 两个函数的接口名用两个函数名命名，例如：ReadWriter
  - 三个以上函数或者不确定未来有多少函数的接口，类似于结构体

### 2.6.变量命名

- 变量命名必须遵循驼峰式，首字母根据包外访问权限决定大小写

- 在相对简单的上下文中，鼓励使用简写例如：

  - user 写为 u
  - userID 写为 uid

- 特有名词，遵循以下规则

  - 如果变量为私有，且特有名词为首个单词，则使用小写，如apiClient
  - 其它情况都应当使用该名词原有的写法，如APIClient、repoID、UserID

  下面列出了一些常用的特有名词

  ```go
  // A GonicMapper that contains a list of common initialisms taken from golang/lint
  var LintGonicMapper = GonicMapper{
      "API":   true,
      "ASCII": true,
      "CPU":   true,
      "CSS":   true,
      "DNS":   true,
      "EOF":   true,
      "GUID":  true,
      "HTML":  true,
      "HTTP":  true,
      "HTTPS": true,
      "ID":    true,
      "IP":    true,
      "JSON":  true,
      "LHS":   true,
      "QPS":   true,
      "RAM":   true,
      "RHS":   true,
      "RPC":   true,
      "SLA":   true,
      "SMTP":  true,
      "SSH":   true,
      "TLS":   true,
      "TTL":   true,
      "UI":    true,
      "UID":   true,
      "UUID":  true,
      "URI":   true,
      "URL":   true,
      "UTF8":  true,
      "VM":    true,
      "XML":   true,
      "XSRF":  true,
      "XSS":   true,
  }
  ```

- 若变量为bool类型，则名称应该为HasXXX，IsXXX，CanXXX或者AllowXXX等开头，例如：

  ```go
  var hasConflict bool
  var isExit bool
  var canManage bool
  var allowGitHook bool
  ```

- 局部变量应该尽可能短小，比如使用buf指代buffer，使用i指代index

- 代码生成工具生成的代码可以排队以上规则，例如（xxx.pb.go）

### 2.7.常量命名

- 常量名必须遵循驼峰式，首字母决定包外访问权限

- 如果是枚举类型常量，需要先创建相应类型

  ```go
  type  Code int
  
  const (
  	ErrUnknown Code = iota
  	ErrFatal
  )
  ```

### 2.8. error 命名

- error类型应该写成FooError的形式

  ```go
  type ExitError struct {
  	// code
  }
  ```

- error 变量写成ErrFoo的形式

  ```go
  var ErrFormat = errors.New("unknow format")
  ```

## 3.注释

- 每个可导出名字都要有注释，该注释对导出的变量、函数、结构体、接口等进行简要介绍

- 全部使用单行注释，禁止使用多行注释

- 禁止使用@param这类描述

- 和代码规范一样，单行注释不要过长，禁止超过120字符，超过时使用换行

- 注释必须是完整的句子，以需要注释的内容作为开头，句点作为结尾，格式为//名称描述，例如：

  ```go
  // bad
  // logs the flags in the flagset.
  func PrintFlags(flags *pflag.FlagSet) {
  	// normal code
  }
  
  // good
  // PrintFlags logs the flags in the flagset.
  func PrintFlags(flags *pflag.FlagSet) {
  	// normal code
  }
  ```

- 所有注释的代码在提交code review前都应该被删除，否则应该说明为什么不删除，并给出后续处理建议

- 在多段注释之间可以使用空行分隔加以区分，如下

  ```go
  // Package superman implements methods for saving the world.
  //
  // Experience has shown that a small number of procedures can prove
  // helpful when attempting to save the world.
  package superman
  ```

### 3.1.包注释

- 每个包都有且仅有一个包级别的注释
- 包注释统一用//注释，格式为//Package包名描述，例如：

### 3.2.变量 / 常量注释

- 每个可导出的变量/常量都需要有注释说明，格式为//变量名变量描述，例如：

  ```go
  // ErrSigningMethod defines invalid signing method error.
  var ErrSigningMethod = errors.New("Invalid signing method")
  ```

- 出现大块常量或变量时，可以前端注释一个总的说明，然后每一行常量的前一行或末尾详细注释该常量的定义，例如：

  ```go
  // Code must start with 1xxxxx.    
  const (                         
      // ErrSuccess - 200: OK.          
      ErrSuccess int = iota + 100001    
                                                     
      // ErrUnknown - 500: Internal server error.    
      ErrUnknown    
  
      // ErrBind - 400: Error occurred while binding the request body to the struct.    
      ErrBind    
                                                    
      // ErrValidation - 400: Validation failed.    
      ErrValidation 
  )
  ```

### 3.3.结构体注释

- 每个需要导出的结构体或者接口都必须有注释说明，格式为//结构体名，结构体描述

- 结构体内的可导出成员变量名，如果意义不明确，必须要给出注释，放在成员变量的前一行或同一行的末尾。例如：

  ```go
  // User represents a user restful resource. It is also used as gorm model.
  type User struct {
      // Standard object's metadata.
      metav1.ObjectMeta `json:"metadata,omitempty"`
  
      Nickname string `json:"nickname" gorm:"column:nickname"`
      Password string `json:"password" gorm:"column:password"`
      Email    string `json:"email" gorm:"column:email"`
      Phone    string `json:"phone" gorm:"column:phone"`
      IsAdmin  int    `json:"isAdmin,omitempty" gorm:"column:isAdmin"`
  }
  ```

### 3.4.方法注释

- 每个需要导出的函数或者方法都必须有注释，格式为//函数名  函数描述. 例如：

  ```go
  // BeforeUpdate run before update database record.
  func (p *Policy) BeforeUpdate() (err error) {
    //  code
    return nil
  }
  ```

### 3.5.类型注释

- 每个要导出的类型定义和类型别名都必须有注释说明，格式为//类型名 类型描述. 例如：

  ```go
  // Code defines an error code type.
  type Code int 
  ```



## 4.数据类型

### 4.1.字符串

- 空字符串判断

  ```go
  // bad
  if s == "" {
  	// code
  }
  
  // good
  if len(s) == 0 {
  	// code
  }
  ```

- []byte/string相等比较

  ```go
  // bad
  var s1 []byte
  var s2 []byte
  ...
  bytes.Equal(s1, s2) == 0
  bytes.Equal(s1, s2) != 0
  
  // good
  var s1 []byte
  var s2 []byte
  ...
  bytes.Compare(s1, s2) == 0
  bytes.Compare(s1, s2) != 0
  ```

- 复杂字符串使用raw字符串避免字符转义

  ```go
  // bad
  regexp.MustCompile("\\.")
  
  // good
  regexp.MustCompile(`\.`)
  ```

### 4.2.切片

- 空slice判断

  ```go
  // bad
  if len(slice) == 0 {
  	// code
  }
  
  // good
  if slice != nil && len(slice) == 0 {
  	// code
  }
  ```

  上面同步适用map、channel

- 声明slice

  ```go
  // bad
  s := []string{}
  s := make([]string, 0)
  
  // good
  var s []string
  ```

- slice复制

  ```go
  // bad
  var b1, b2 []byte
  for i, v := range b1 {
  	b2[i] = v
  }
  for i := range b1 {
  	b2[i] = b1[i]
  }
  
  // good
  copy(b2, b1)
  ```

- slice新增

  ```go
  // bad
  var a, b []int
  for _, v := range a {
  	b = append(b, v)
  }
  
  // good
  var a, b []int 
  b = append(b, a...)
  ```



## 5.控制结构

### 5.1.if

- if 接受初始化语句，约定如下方式建立局部变量

  ```go
  if err := loadConfig(); err != nil {
  	// erro handle
  	return err 
  }
  ```

- if 对于bool类型的变量，应直接进行真假判断

  ```go
  var isAllow bool
  if isAllow {
  	// code
  }
  ```

### 5.2.for

- 采用短声明建立局部变量

  ```go
  sum := 0
  for i := 0; i < 10; i++ {
  	sum += 1
  }
  ```

- 不要在for循环里使用defer

  ```go
  // bad
  for file := range files {
  	fd, err := os.Open(file)
  	if err != nil {
  		return err 
  	}
  	defer fd.Close()
  }
  
  // good
  for file := range files {
  	func() {
  		fd, err := os.Open(file)
  		if err != nil {
  			return err 
  		}
  		defer fd.Close()
  	}()
  }
  ```

### 5.3.range

- 如果只需要第一项(key)，就丢弃第二个

  ```go
  for key := range keys {
  	// code
  }
  ```

- 如果只需要第二项，第一项下划线

  ```go
  sum := 0
  for _, val := range arr {
  	sum += val
  }
  ```

### 5.4. switch

- 必须要有default

### 5.5. goto

- 业务代码禁止使用goto
- 框架或工具库等其它公共代码尽量不用



### 6.函数

- 传入变量和返回变量以小写字母开头

- 函数参数不能超过5个

- 函数分组与顺序

  - 函数应按粗略的调用顺序排序

  - 同一文件中的函数按功能分组

    ```go
    func (m *userModel) FindOne()
    func (m *userModel) FindByUserId()
    func (m *userModel) FincXXX()
    ...
    func (m *userModel) Update()
    func (m *userModel) UpdateByUserId()
    ...
    ```

- 尽量采用值传递

- 传入参数map、slice、chan、interface，不要传指针

### 6.1.函数参数

- 如果函数返回相同类型的两个或三个参数，或者如果从上下文中不清楚结果的含义，使用命名返回，除此之外不使用命名返回，例如：

  ```go
  func coordinate() (x, y float64, err error) {
  	// code
  }
  ```

- 传入变量和返回变量都以小写字母开头

- 尽量用值传递，非指针传递

- 参数数量均不能超过5个

- 多返回值最多返回三个，超过三个使用struct 

### 6.2.defer

- 先判断是否错误，再deder释放资源，例如：

  ```go
  rep, err := http.Get(url)
  if err != nil {
  	return err
  }
  defer resp.Body.Close()
  ```

### 6.3.方法的接收器

- 推荐以类名第一个英文首字母的小写作为接收器命名，例如：

  ```go
  func(u *User) UserInfo()
  func(m *UserModel) FindOne()
  ```

- 禁止使用me、this、self这类命名



## 7.Redis使用

#### 7.1. Redis KEY

1. Redis的Key使用全大写命名，多个单词/多级使用 "::"分隔。例如：USER::INFO::REGION

2. Redis的Key应尽量短（建议）

4. 服务独有KEY，要加服务名前缀

   

